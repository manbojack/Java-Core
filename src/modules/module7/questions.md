## Функциональные интерфейсы:

####  Зачем нужно функциональное программирование, где оно применяется и в чем его отличие от программирования в стиле ооп или в процедурном стиле?
>FP предлагает такие преимущества, как ленивое вычисление, код без ошибок, вложенные 
функции, параллельное программирование. Он использует более декларативный подход, 
который концентрируется на том, что нужно сделать, и меньше на том, как это делать, 
с упором на эффективность и оптимизацию.  
> 
>В функциональном программировании гораздо проще узнать, какие изменения были внесены,
поскольку сам объект теперь является новым объектом с другим именем. Это эффективно,
когда у вас есть фиксированный набор операций, и по мере развития вашего кода вы 
добавляете новые операции к существующим вещам.
> Он хорошо работает, когда границы либо не требуются, либо уже предопределены. 
Это наиболее полезно в ситуациях, когда состояние не является фактором и переменные 
данные практически не задействованы.
>
>В функциональном программировании проще моделировать реальные процессы, чем объекты. 
Его математическое происхождение делает его подходящим для случаев, требующих 
вычислений или всего, что включает преобразование и обработку. ООП в таких 
случаях будет неэффективным.

#### Что такое функциональный интерфейс?
>Если интерфейс в Java содержит один и только один абстрактный метод, то он называется 
функциональным. Этот единственный метод определяет назначение интерфейса.

#### Зачем нужна аннотация @FunctionalInterface? Обязательна ли она?
>К функциональному интерфейсу можно добавить аннотацию @FunctionalInterface. 
Это не обязательно, но при наличии данной аннотации код не скомпилируется, если 
будет больше или меньше, чем 1 абстрактный метод.

#### Что такое default методы в интерфейсе и для чего они были введены?
>Это метод, который реализуется прямо в интерфейсе.  
Default-методы упрощают рефакторинг — а именно, добавление новых методов,
расширение интерфейсов с сохранением обратной совместимости

#### Может ли функциональный интерфейс содержать что-то кроме абстрактного метода?
>Да, может содержать, например: методы с сигнатурой из Object класса, методы
default и static.

#### Все способы реализации функционального интерфейса?
>- С помощью <b>анонимного класса</b>
>- С помощью <b>лямбда - выражения</b>.
>- С помощью ссылки на метод ( <b>референс</b> )
>- С помощью <b>обычного класса</b>, путем имплементации

#### Что такое метод референс?
>Синтаксический сахар для записи лямбда-выражений ещё короче.

#### Что такое «анонимные классы»?
>Класс, объявленный без имени.

#### Как создать экземпляр анонимного класса?
>- как реализация интерфейса
>- как наследник определённого класса

#### Что такое лямбда-выражение? Как его записать?
>Их основная цель – повысить читабельность и уменьшить количество кода.

#### Расскажите про Comparator и Comparable?
>Интерфейс <b>Comparable</b> содержит один единственный метод int compareTo(E item), 
который сравнивает текущий объект с объектом, переданным в качестве параметра. 
Если этот метод возвращает отрицательное число, то текущий объект будет располагаться 
перед тем, который передается через параметр. Если метод вернет положительное число, 
то, наоборот, после второго объекта. Если метод возвратит ноль, значит, оба объекта равны.
> 
>В интерфейсе <b>Comparator</b> объявлен метод compare (Object obj1, Object obj2), который
позволяет сравнивать между собой два объекта. На выходе метод возвращает значение 0,
если объекты равны, положительное значение или отрицательное значение, если объекты 
не тождественны. Метод может вызвать исключение ClassCastException, если типы объектов 
не совместимы при сравнении.
> 
> Интерфейс <b>Comparable</b> используется только для сравнения объектов класса, в котором 
данный интерфейс реализован. Т.е. interface Comparable определяет логику сравнения объекта
определенного ссылочного типа внутри своей реализации (по правилам разработчика).  
<b>Comparator</b> представляет отдельную реализацию и ее можно использовать многократно и 
с различными классами. Т.е. interface Comparator позволяет создавать объекты, которые 
будут управлять процессом сравнения (например при сортировках).


## Stream API:

#### Что такое стримы? Для чего они нужны? Когда их лучше использовать?
>Это новый инструмент языка Java, который позволяет использовать функциональный стиль при 
работе с разными структурами данных.
###
#### Какие есть виды стримов?
>В Java 8 Stream API доступны методы двух видов — конвейерные и терминальные.
###
#### Способы создания Стрима?
>
>| Источник | Способ | Пример |
>|------------------|--------|---
>|Коллекция|collection.stream()| Collection<String> collection = Arrays.asList("f5", "b6", "z7");
>|Значения|Stream.of(v1,… vN)| Stream<String> valuesS = Stream.of("f5", "b6", "z7"); 
>|Примитивы|IntStream.of(1, … N)|IntStream intS = IntStream.of(9, 8, 7);
>| -     |DoubleStream.of(1.1, … N)| DoubleStream doubleS = DoubleStream.of(2.4, 8.9);
>| Массив|Arrays.stream(arr)	|String[] arr = {"f5","b6","z7"}; 
>|- |- | Stream<String> arrS = Arrays.stream(arr);
>|Файл - каждая новая строка становится элементом|Files.lines(file_path)	|Stream<String> fromFileS = Files.lines(Paths.get("doc.txt"))
>|Stream.builder	|Stream.builder().add(...)|Stream.builder().add("f5").add("b6").build()



#### Что такое терминальная операция?
>Операция, которая завершает пайплайн из стримов.


#### Что возвращают промежуточные операции над стримом?
> возвращает очередной стрим

#### В чем разница map и flatMap?
>- `map` для каждого объекта в стриме возвращает по 1 объекту, потом преобразует 
все объекты в итоговый стрим.
>- `flatMap` возвращает по стриму для каждого объекта в первоначальном стриме, 
а затем результирующие потоки объединяются в исходный стрим. 

#### Что такое ленивая инициализация стрима?
>не выполняется, пока не вызовется терминальная операция

#### Можно ли вызвать 2 терминальные операции? 
>Нельзя: после вызова терминальной операции стрим нельзя больше использовать.

#### Что будет, если терминальной операции не будет?
>Стрим просто не выполнится

#### Может ли стрим использоваться повторно?
>Stream нельзя использовать несколько раз. Поток пропускается один раз. 
По этому, если цикл повторяется больше одного раза то код работает не корректно.

#### Для чего нужны параллельные стримы?
>Фактически применение параллельных потоков сводится к тому, что данные в потоке будут разделены на части, каждая 
часть обрабатывается на отдельном ядре процессора, и в конце эти части соединяются, 
и над ними выполняются финальные операции

#### В чём разница между forEach и peek?
> `forEach` - терминальный метод, `peek` - промежуточный (служит для отладки)
>