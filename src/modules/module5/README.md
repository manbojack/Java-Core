#### Что такое потоки ввода-вывода? Как это реализовано в Java?
>Объект, из которого можно считать данные, называется потоком ввода, 
а объект, в который можно записывать данные, - потоком вывода. 
Например, если надо считать содержание файла, то применяется поток ввода, 
а если надо записать в файл - то поток вывода.

>В основе всех классов, управляющих потоками байтов, находятся два абстрактных класса: InputStream (представляющий потоки ввода) и OutputStream (представляющий потоки вывода)
Но поскольку работать с байтами не очень удобно, то для работы с потоками символов были добавлены абстрактные классы Reader (для чтения потоков символов) и Writer (для записи потоков символов).
Все остальные классы, работающие с потоками, являются наследниками этих абстрактных классов.
#### Что делает метод read?
>- int read(): возвращает целочисленное представление следующего байта в потоке. Когда в потоке не останется доступных для чтения байтов, данный метод возвратит число -1
>- int read(byte[] buffer): считывает байты из потока в массив buffer. После чтения возвращает число считанных байтов. Если ни одного байта не было считано, то возвращается число -1
>- int read(byte[] buffer, int offset, int length): считывает некоторое количество байтов, равное length, из потока в массив buffer. При этом считанные байты помещаются в массиве, начиная со смещения offset, то есть с элемента buffer[offset]. Метод возвращает число успешно прочитанных байтов.
#### Что такое System.in, что такое System.out?
> Это два абстрактных класса представляющие потоки ввода и вывода.
>Стандартный поток ввода (клавиатура) в Java представлен объектом — System.in. 
А стандартный поток вывода (дисплей) — объектом System.out. Есть ещё стандартный поток для вывода ошибок — System.err. 
#### Что делает flush?  Почему важно закрывать потоки?
>flush() записывает содержимое буфера в место назначения и делает буфер 
пустым для дальнейшего хранения данных, но не закрывает поток навсегда. Это означает, что вы все еще можете записать в поток еще несколько данных.

>При закрытии потока освобождаются все выделенные под него ресурсы. Закрытие потока выполняется с помощью метода close(), либо с помощью try-with-resources.

#### Расскажи про классы Reader и Writer?
>Абстрактный класс Reader предоставляет функционал для чтения текстовой 
информации. Рассмотрим его основные методы:
>- absract void close(): закрывает поток ввода
>- int read(): возвращает целочисленное представление следующего символа в потоке. 
Если таких символов нет, и достигнут конец файла, то возвращается число -1
>- int read(char[] buffer): считывает в массив buffer из потока символы, 
количество которых равно длине массива buffer. 
Возвращает количество успешно считанных символов. При достижении конца файла возвращает -1
>- int read(CharBuffer buffer): считывает в объект CharBuffer из потока символы. Возвращает количество успешно считанных символов. При достижении конца файла возвращает -1
>- absract int read(char[] buffer, int offset, int count): считывает в массив buffer, начиная со смещения offset, из потока символы, количество которых равно count

>Класс Writer определяет функционал для всех символьных потоков вывода. Его основные методы:
>- Writer append(char c): добавляет в конец выходного потока символ c. Возвращает объект Writer
>- Writer append(CharSequence chars): добавляет в конец выходного потока набор символов chars. Возвращает объект Writer
abstract void close(): закрывает поток
>- abstract void flush(): очищает буферы потока
>- void write(int c): записывает в поток один символ, который имеет целочисленное представление
>- void write(char[] buffer): записывает в поток массив символов
>- absract void write(char[] buffer, int off, int len) : записывает в поток только несколько символов из массива buffer. Причем количество символов равно len, а отбор символов из массива начинается с индекса off
>- void write(String str): записывает в поток строку
>- void write(String str, int off, int len): записывает в поток из строки некоторое количество символов, которое равно len, причем отбор символов из строки начинается с индекса off
#### Как преобразовать считанные байты в символы? Какой класс для этого используется?
>
#### Отличие Scanner’a от BufferedReader’a?
>Экземпляры класса java.io.BufferedReader предназначены для чтения потока символов с буферизацией (символов, массивов и строк).  
>Экземпляры класса java.util.Scanner предназначены для разбора данных на составляющие с учетом форматов, шаблонов, разных разделителей. Входные данные для Scanner могут быть файлы, потоки байтов, потоки символов, строки.
#### Отличие пакета io от nio?
>IO:
>- Потокоориентированный
>- Блокирующий (синхронный) ввод/вывод 

>NIO:
>- Буфер-ориентированный
>- Неблокирующий (асинхронный) ввод/вывод
>- Селекторы (?)
#### Расскажи про класс File? Как создать новый файл на жестком диске?
> Создать экземпляр класса io.File или nio.Files и вызвать соответсвующие методы:
>- java.io: (File) file.createNewFile()
>- java.nio: Files.createFile()
#### В чём отличие File от Path?
> 
#### В чем разница между абсолютным и относительным путем?
> абсолютный путь - путь, начиная с корневой директории   
> относительный - путь относительно какой-то директории
#### Что такое клонирование? Как реализовано клонирование в Java?
> <b>Клонирование</b> - процесс создания точной копии класса на основе существующего.   
> Для клонирования объекта в Java можно воспользоваться тремя способами:
>- Переопределение метода clone() и реализация интерфейса Cloneable().
>- Использование конструктора копирования.
>- Использовать механизм сериализации.
#### Как удалить директорию с файлами?
>file.delete()  
Нужно прописать вручную рекурсивный обход для удаления всех файлов в директории и поддиректорий.     
>Для класса nio.Files использовать метод walkFileTree()
#### В чём разница между поверхностным и глубоким клонированием? Как реализовать глубокое клонирование?
> 
#### Что такое сериализация и десериализация?
>- Сериализация — это процесс сохранения состояния объекта в последовательность байт.
>- Десериализация — это процесс восстановления объекта из этих байт
#### Назовите несколько форматов сериализации.
>- JSON. JavaScript Object Notation
>- BSON (binary JSON)
>- YAML. Yet Another Markup Lang. YAML Ain't ML
>- XML.
#### Какие поля не сериализуются?
> Статические?
#### Как сериализовать статическое поле?
>